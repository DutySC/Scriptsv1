============================= test session starts =============================
platform win32 -- Python 3.10.9, pytest-7.2.2, pluggy-1.0.0
rootdir: C:\Users\timur\PycharmProjects\pythonProject\Scriptsv1
plugins: allure-pytest-2.13.0, html-3.2.0, metadata-2.0.4, xdist-3.3.1, testit-adapter-pytest-2.1.8
collected 1 item

Курска.py =================

F

================================== FAILURES ===================================
_____________________________ Test_KURO.test_KURO _____________________________

self = <KURO.page_object.login_page.login object at 0x000001B7816CB250>

    def auth(self):
        try:
            print('=================\n')
>           user = self.find_element(login_locators.LOCATOR_USER) # логин

KURO\page_object\login_page.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <KURO.page_object.login_page.login object at 0x000001B7816CB250>
locator = ('xpath', '//tr[1]/td[3]//input[1]'), time = 60

    def find_element(self, locator, time=60):
>       return WebDriverWait(self.driver, time).until(ES.presence_of_element_located(locator), message=f'Not found {locator}')

BASE_PAGE.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <selenium.webdriver.support.wait.WebDriverWait (session="b606230d131d12b2a7ce60eccc7f8b83")>
method = <function presence_of_element_located.<locals>._predicate at 0x000001B7816E7D00>
message = "Not found ('xpath', '//tr[1]/td[3]//input[1]')"

    def until(self, method, message: str = ""):
        """Calls the method provided with the driver as an argument until the \
        return value does not evaluate to ``False``.
    
        :param method: callable(WebDriver)
        :param message: optional message for :exc:`TimeoutException`
        :returns: the result of the last call to `method`
        :raises: :exc:`selenium.common.exceptions.TimeoutException` if timeout occurs
        """
        screen = None
        stacktrace = None
    
        end_time = time.monotonic() + self._timeout
        while True:
            try:
>               value = method(self._driver)

..\..\..\AppData\Local\Programs\Python\Python310\lib\site-packages\selenium\webdriver\support\wait.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

driver = <selenium.webdriver.chrome.webdriver.WebDriver (session="b606230d131d12b2a7ce60eccc7f8b83")>

    def _predicate(driver):
>       return driver.find_element(*locator)

..\..\..\AppData\Local\Programs\Python\Python310\lib\site-packages\selenium\webdriver\support\expected_conditions.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="b606230d131d12b2a7ce60eccc7f8b83")>
by = 'xpath', value = '//tr[1]/td[3]//input[1]'

    def find_element(self, by=By.ID, value: Optional[str] = None) -> WebElement:
        """Find an element given a By strategy and locator.
    
        :Usage:
            ::
    
                element = driver.find_element(By.ID, 'foo')
    
        :rtype: WebElement
        """
        if isinstance(by, RelativeBy):
            elements = self.find_elements(by=by, value=value)
            if not elements:
                raise NoSuchElementException(f"Cannot locate relative element with: {by.root}")
            return elements[0]
    
        if by == By.ID:
            by = By.CSS_SELECTOR
            value = f'[id="{value}"]'
        elif by == By.CLASS_NAME:
            by = By.CSS_SELECTOR
            value = f".{value}"
        elif by == By.NAME:
            by = By.CSS_SELECTOR
            value = f'[name="{value}"]'
    
>       return self.execute(Command.FIND_ELEMENT, {"using": by, "value": value})["value"]

..\..\..\AppData\Local\Programs\Python\Python310\lib\site-packages\selenium\webdriver\remote\webdriver.py:830: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <selenium.webdriver.chrome.webdriver.WebDriver (session="b606230d131d12b2a7ce60eccc7f8b83")>
driver_command = 'findElement'
params = {'using': 'xpath', 'value': '//tr[1]/td[3]//input[1]'}

    def execute(self, driver_command: str, params: dict = None) -> dict:
        """Sends a command to be executed by a command.CommandExecutor.
    
        :Args:
         - driver_command: The name of the command to execute as a string.
         - params: A dictionary of named parameters to send with the command.
    
        :Returns:
          The command's JSON response loaded into a dictionary object.
        """
        params = self._wrap_value(params)
    
        if self.session_id:
            if not params:
                params = {"sessionId": self.session_id}
            elif "sessionId" not in params:
                params["sessionId"] = self.session_id
    
        response = self.command_executor.execute(driver_command, params)
        if response:
>           self.error_handler.check_response(response)

..\..\..\AppData\Local\Programs\Python\Python310\lib\site-packages\selenium\webdriver\remote\webdriver.py:440: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x000001B7816CABF0>
response = {'status': 404, 'value': '{"value":{"error":"no such window","message":"no such window: target window already closed\\...\n\\tRtlGetAppContainerNamedObjectPath [0x76F67B4E+286]\\n\\tRtlGetAppContainerNamedObjectPath [0x76F67B1E+238]\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value.keys()) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        if status in ErrorCode.NO_SUCH_ELEMENT:
            exception_class = NoSuchElementException
        elif status in ErrorCode.NO_SUCH_FRAME:
            exception_class = NoSuchFrameException
        elif status in ErrorCode.NO_SUCH_SHADOW_ROOT:
            exception_class = NoSuchShadowRootException
        elif status in ErrorCode.NO_SUCH_WINDOW:
            exception_class = NoSuchWindowException
        elif status in ErrorCode.STALE_ELEMENT_REFERENCE:
            exception_class = StaleElementReferenceException
        elif status in ErrorCode.ELEMENT_NOT_VISIBLE:
            exception_class = ElementNotVisibleException
        elif status in ErrorCode.INVALID_ELEMENT_STATE:
            exception_class = InvalidElementStateException
        elif (
            status in ErrorCode.INVALID_SELECTOR
            or status in ErrorCode.INVALID_XPATH_SELECTOR
            or status in ErrorCode.INVALID_XPATH_SELECTOR_RETURN_TYPER
        ):
            exception_class = InvalidSelectorException
        elif status in ErrorCode.ELEMENT_IS_NOT_SELECTABLE:
            exception_class = ElementNotSelectableException
        elif status in ErrorCode.ELEMENT_NOT_INTERACTABLE:
            exception_class = ElementNotInteractableException
        elif status in ErrorCode.INVALID_COOKIE_DOMAIN:
            exception_class = InvalidCookieDomainException
        elif status in ErrorCode.UNABLE_TO_SET_COOKIE:
            exception_class = UnableToSetCookieException
        elif status in ErrorCode.TIMEOUT:
            exception_class = TimeoutException
        elif status in ErrorCode.SCRIPT_TIMEOUT:
            exception_class = TimeoutException
        elif status in ErrorCode.UNKNOWN_ERROR:
            exception_class = WebDriverException
        elif status in ErrorCode.UNEXPECTED_ALERT_OPEN:
            exception_class = UnexpectedAlertPresentException
        elif status in ErrorCode.NO_ALERT_OPEN:
            exception_class = NoAlertPresentException
        elif status in ErrorCode.IME_NOT_AVAILABLE:
            exception_class = ImeNotAvailableException
        elif status in ErrorCode.IME_ENGINE_ACTIVATION_FAILED:
            exception_class = ImeActivationFailedException
        elif status in ErrorCode.MOVE_TARGET_OUT_OF_BOUNDS:
            exception_class = MoveTargetOutOfBoundsException
        elif status in ErrorCode.JAVASCRIPT_ERROR:
            exception_class = JavascriptException
        elif status in ErrorCode.SESSION_NOT_CREATED:
            exception_class = SessionNotCreatedException
        elif status in ErrorCode.INVALID_ARGUMENT:
            exception_class = InvalidArgumentException
        elif status in ErrorCode.NO_SUCH_COOKIE:
            exception_class = NoSuchCookieException
        elif status in ErrorCode.UNABLE_TO_CAPTURE_SCREEN:
            exception_class = ScreenshotException
        elif status in ErrorCode.ELEMENT_CLICK_INTERCEPTED:
            exception_class = ElementClickInterceptedException
        elif status in ErrorCode.INSECURE_CERTIFICATE:
            exception_class = InsecureCertificateException
        elif status in ErrorCode.INVALID_COORDINATES:
            exception_class = InvalidCoordinatesException
        elif status in ErrorCode.INVALID_SESSION_ID:
            exception_class = InvalidSessionIdException
        elif status in ErrorCode.UNKNOWN_METHOD:
            exception_class = UnknownMethodException
        else:
            exception_class = WebDriverException
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.NoSuchWindowException: Message: no such window: target window already closed
E       from unknown error: web view not found
E         (Session info: chrome=114.0.5735.110)
E       Stacktrace:
E       Backtrace:
E       	GetHandleVerifier [0x01146E73+48323]
E       	(No symbol) [0x010D9661]
E       	(No symbol) [0x00FE5308]
E       	(No symbol) [0x00FCD243]
E       	(No symbol) [0x0102E51B]
E       	(No symbol) [0x0103C613]
E       	(No symbol) [0x0102A6D6]
E       	(No symbol) [0x0100847C]
E       	(No symbol) [0x0100957D]
E       	GetHandleVerifier [0x013AFD5D+2575277]
E       	GetHandleVerifier [0x013EF86E+2836158]
E       	GetHandleVerifier [0x013E96DC+2811180]
E       	GetHandleVerifier [0x011D41B0+626688]
E       	(No symbol) [0x010E314C]
E       	(No symbol) [0x010DF4B8]
E       	(No symbol) [0x010DF59B]
E       	(No symbol) [0x010D21B7]
E       	BaseThreadInitThunk [0x74DC00C9+25]
E       	RtlGetAppContainerNamedObjectPath [0x76F67B4E+286]
E       	RtlGetAppContainerNamedObjectPath [0x76F67B1E+238]

..\..\..\AppData\Local\Programs\Python\Python310\lib\site-packages\selenium\webdriver\remote\errorhandler.py:245: NoSuchWindowException

During handling of the above exception, another exception occurred:

self = <Курска.Test_KURO object at 0x000001B7816CA9E0>
browser_KURO = <selenium.webdriver.chrome.webdriver.WebDriver (session="b606230d131d12b2a7ce60eccc7f8b83")>

    @testit.workItemIds(214620, 214621, 214622, 214623, 214624)
    @testit.displayName('Курская область')
    @testit.title('Крит. модули')
    @testit.labels('AUTOTEST_SC')
    @testit.link('https://testit.bars.group//projects/214392/tests?isolatedSection=209dbcc0-ff8d-4f70-a294-d204c5b97dfb')
    def test_KURO(self, browser_KURO):
        start = time.time()  # начало отсчета
>       full_test_KURO.test_KURO_login(browser_KURO)  # тест "Авторизации"

Курска.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\AppData\Local\Programs\Python\Python310\lib\site-packages\testit_python_commons\step.py:52: in step_wrapper
    return function(*a, **kw)
KURO\full_test_KURO.py:13: in test_KURO_login
    start_page.auth()
KURO\page_object\login_page.py:52: in auth
    self.get_screenshots('Results/Results_sc/Авторизация.png')
BASE_PAGE.py:26: in get_screenshots
    return self.driver.save_screenshot(name)
..\..\..\AppData\Local\Programs\Python\Python310\lib\site-packages\selenium\webdriver\remote\webdriver.py:916: in save_screenshot
    return self.get_screenshot_as_file(filename)
..\..\..\AppData\Local\Programs\Python\Python310\lib\site-packages\selenium\webdriver\remote\webdriver.py:892: in get_screenshot_as_file
    png = self.get_screenshot_as_png()
..\..\..\AppData\Local\Programs\Python\Python310\lib\site-packages\selenium\webdriver\remote\webdriver.py:926: in get_screenshot_as_png
    return b64decode(self.get_screenshot_as_base64().encode("ascii"))
..\..\..\AppData\Local\Programs\Python\Python310\lib\site-packages\selenium\webdriver\remote\webdriver.py:937: in get_screenshot_as_base64
    return self.execute(Command.SCREENSHOT)["value"]
..\..\..\AppData\Local\Programs\Python\Python310\lib\site-packages\selenium\webdriver\remote\webdriver.py:440: in execute
    self.error_handler.check_response(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x000001B7816CABF0>
response = {'status': 404, 'value': '{"value":{"error":"no such window","message":"no such window: target window already closed\\...\n\\tRtlGetAppContainerNamedObjectPath [0x76F67B4E+286]\\n\\tRtlGetAppContainerNamedObjectPath [0x76F67B1E+238]\\n"}}'}

    def check_response(self, response: Dict[str, Any]) -> None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        :Args:
         - response - The JSON response from the WebDriver server as a dictionary
           object.
    
        :Raises: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                import json
    
                try:
                    value = json.loads(value_json)
                    if len(value.keys()) == 1:
                        value = value["value"]
                    status = value.get("error", None)
                    if not status:
                        status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                        message = value.get("value") or value.get("message")
                        if not isinstance(message, str):
                            value = message
                            message = message.get("message")
                    else:
                        message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: Type[WebDriverException]
        if status in ErrorCode.NO_SUCH_ELEMENT:
            exception_class = NoSuchElementException
        elif status in ErrorCode.NO_SUCH_FRAME:
            exception_class = NoSuchFrameException
        elif status in ErrorCode.NO_SUCH_SHADOW_ROOT:
            exception_class = NoSuchShadowRootException
        elif status in ErrorCode.NO_SUCH_WINDOW:
            exception_class = NoSuchWindowException
        elif status in ErrorCode.STALE_ELEMENT_REFERENCE:
            exception_class = StaleElementReferenceException
        elif status in ErrorCode.ELEMENT_NOT_VISIBLE:
            exception_class = ElementNotVisibleException
        elif status in ErrorCode.INVALID_ELEMENT_STATE:
            exception_class = InvalidElementStateException
        elif (
            status in ErrorCode.INVALID_SELECTOR
            or status in ErrorCode.INVALID_XPATH_SELECTOR
            or status in ErrorCode.INVALID_XPATH_SELECTOR_RETURN_TYPER
        ):
            exception_class = InvalidSelectorException
        elif status in ErrorCode.ELEMENT_IS_NOT_SELECTABLE:
            exception_class = ElementNotSelectableException
        elif status in ErrorCode.ELEMENT_NOT_INTERACTABLE:
            exception_class = ElementNotInteractableException
        elif status in ErrorCode.INVALID_COOKIE_DOMAIN:
            exception_class = InvalidCookieDomainException
        elif status in ErrorCode.UNABLE_TO_SET_COOKIE:
            exception_class = UnableToSetCookieException
        elif status in ErrorCode.TIMEOUT:
            exception_class = TimeoutException
        elif status in ErrorCode.SCRIPT_TIMEOUT:
            exception_class = TimeoutException
        elif status in ErrorCode.UNKNOWN_ERROR:
            exception_class = WebDriverException
        elif status in ErrorCode.UNEXPECTED_ALERT_OPEN:
            exception_class = UnexpectedAlertPresentException
        elif status in ErrorCode.NO_ALERT_OPEN:
            exception_class = NoAlertPresentException
        elif status in ErrorCode.IME_NOT_AVAILABLE:
            exception_class = ImeNotAvailableException
        elif status in ErrorCode.IME_ENGINE_ACTIVATION_FAILED:
            exception_class = ImeActivationFailedException
        elif status in ErrorCode.MOVE_TARGET_OUT_OF_BOUNDS:
            exception_class = MoveTargetOutOfBoundsException
        elif status in ErrorCode.JAVASCRIPT_ERROR:
            exception_class = JavascriptException
        elif status in ErrorCode.SESSION_NOT_CREATED:
            exception_class = SessionNotCreatedException
        elif status in ErrorCode.INVALID_ARGUMENT:
            exception_class = InvalidArgumentException
        elif status in ErrorCode.NO_SUCH_COOKIE:
            exception_class = NoSuchCookieException
        elif status in ErrorCode.UNABLE_TO_CAPTURE_SCREEN:
            exception_class = ScreenshotException
        elif status in ErrorCode.ELEMENT_CLICK_INTERCEPTED:
            exception_class = ElementClickInterceptedException
        elif status in ErrorCode.INSECURE_CERTIFICATE:
            exception_class = InsecureCertificateException
        elif status in ErrorCode.INVALID_COORDINATES:
            exception_class = InvalidCoordinatesException
        elif status in ErrorCode.INVALID_SESSION_ID:
            exception_class = InvalidSessionIdException
        elif status in ErrorCode.UNKNOWN_METHOD:
            exception_class = UnknownMethodException
        else:
            exception_class = WebDriverException
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "<anonymous>")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "<anonymous>")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
>       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.NoSuchWindowException: Message: no such window: target window already closed
E       from unknown error: web view not found
E         (Session info: chrome=114.0.5735.110)
E       Stacktrace:
E       Backtrace:
E       	GetHandleVerifier [0x01146E73+48323]
E       	(No symbol) [0x010D9661]
E       	(No symbol) [0x00FE5308]
E       	(No symbol) [0x00FCD243]
E       	(No symbol) [0x0102E51B]
E       	(No symbol) [0x0103C613]
E       	(No symbol) [0x0102A6D6]
E       	(No symbol) [0x0100847C]
E       	(No symbol) [0x0100957D]
E       	GetHandleVerifier [0x013AFD5D+2575277]
E       	GetHandleVerifier [0x013EF86E+2836158]
E       	GetHandleVerifier [0x013E96DC+2811180]
E       	GetHandleVerifier [0x011D41B0+626688]
E       	(No symbol) [0x010E314C]
E       	(No symbol) [0x010DF4B8]
E       	(No symbol) [0x010DF59B]
E       	(No symbol) [0x010D21B7]
E       	BaseThreadInitThunk [0x74DC00C9+25]
E       	RtlGetAppContainerNamedObjectPath [0x76F67B4E+286]
E       	RtlGetAppContainerNamedObjectPath [0x76F67B1E+238]

..\..\..\AppData\Local\Programs\Python\Python310\lib\site-packages\selenium\webdriver\remote\errorhandler.py:245: NoSuchWindowException
============================== warnings summary ===============================
Курска.py:15
  C:\Users\timur\PycharmProjects\pythonProject\Scriptsv1\Курска.py:15: DeprecationWarning: "link" is no longer acceptable to compute time between versions.
  Use "links" instead.
    @testit.link('https://testit.bars.group//projects/214392/tests?isolatedSection=209dbcc0-ff8d-4f70-a294-d204c5b97dfb')

Курска.py::Test_KURO::test_KURO
Курска.py::Test_KURO::test_KURO
  C:\Users\timur\AppData\Local\Programs\Python\Python310\lib\site-packages\testit_api_client\rest.py:42: DeprecationWarning: HTTPResponse.getheader() is deprecated and will be removed in urllib3 v2.1.0. Instead use HTTPResponse.headers.get(name, default).
    return self.urllib3_response.getheader(name, default)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ===========================
FAILED Курска.py::Test_KURO::test_KURO - selenium.common.exceptions.NoSuchWin...
======================== 1 failed, 3 warnings in 4.75s ========================
